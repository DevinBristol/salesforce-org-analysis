// src/services/mock-framework-generator.js - Mock Framework Code Generator

/**
 * Generates mock implementations for testing external dependencies
 */
export class MockFrameworkGenerator {
    constructor(logger) {
        this.logger = logger;
    }

    /**
     * Generates an HttpCalloutMock implementation for REST API testing
     * @param {string} mockClassName - Name for the mock class
     * @param {Array} endpoints - Array of {method, endpoint, statusCode, responseBody} objects
     * @returns {string} Complete Apex mock class code
     */
    generateHttpCalloutMock(mockClassName, endpoints) {
        const responses = endpoints.map((ep, index) => {
            return `            ${index > 0 ? '} else ' : ''}if (request.getMethod() == '${ep.method}' && request.getEndpoint().contains('${ep.endpoint}')) {
                response.setStatusCode(${ep.statusCode});
                response.setBody('${this.escapeJson(ep.responseBody)}');`;
        }).join('\n');

        return `/**
 * Mock HTTP Callout for testing external API integrations
 * Generated by Salesforce Autonomous Dev System
 */
@isTest
public class ${mockClassName} implements HttpCalloutMock {
    private String responseBody;
    private Integer statusCode;
    private Map<String, String> responseHeaders;

    /**
     * Constructor with default 200 OK response
     */
    public ${mockClassName}() {
        this(200, '{"success": true}', new Map<String, String>());
    }

    /**
     * Constructor for custom response configuration
     * @param statusCode HTTP status code to return
     * @param responseBody JSON response body
     */
    public ${mockClassName}(Integer statusCode, String responseBody) {
        this(statusCode, responseBody, new Map<String, String>());
    }

    /**
     * Full constructor with headers
     * @param statusCode HTTP status code to return
     * @param responseBody JSON response body
     * @param responseHeaders HTTP headers to include in response
     */
    public ${mockClassName}(Integer statusCode, String responseBody, Map<String, String> responseHeaders) {
        this.statusCode = statusCode;
        this.responseBody = responseBody;
        this.responseHeaders = responseHeaders;
    }

    /**
     * Implements HttpCalloutMock interface
     * @param request The HTTP request to mock
     * @return Mocked HTTP response
     */
    public HTTPResponse respond(HTTPRequest request) {
        HTTPResponse response = new HTTPResponse();

        // Set configured response
        response.setStatusCode(this.statusCode);
        response.setBody(this.responseBody);

        // Add headers
        for (String headerKey : this.responseHeaders.keySet()) {
            response.setHeader(headerKey, this.responseHeaders.get(headerKey));
        }

        // Default Content-Type if not specified
        if (!this.responseHeaders.containsKey('Content-Type')) {
            response.setHeader('Content-Type', 'application/json');
        }

        return response;
    }

    /**
     * Builder method to set response body
     * @param body Response body string
     * @return This mock instance for method chaining
     */
    public ${mockClassName} withBody(String body) {
        this.responseBody = body;
        return this;
    }

    /**
     * Builder method to set status code
     * @param code HTTP status code
     * @return This mock instance for method chaining
     */
    public ${mockClassName} withStatusCode(Integer code) {
        this.statusCode = code;
        return this;
    }

    /**
     * Builder method to add response header
     * @param key Header name
     * @param value Header value
     * @return This mock instance for method chaining
     */
    public ${mockClassName} withHeader(String key, String value) {
        this.responseHeaders.put(key, value);
        return this;
    }
}`;
    }

    /**
     * Generates a multi-endpoint HttpCalloutMock with endpoint-specific responses
     * @param {string} mockClassName - Name for the mock class
     * @param {Array} endpoints - Array of endpoint configurations
     * @returns {string} Complete Apex mock class with routing logic
     */
    generateMultiEndpointMock(mockClassName, endpoints) {
        const responseMap = endpoints.map(ep => {
            return `        endpointResponses.put('${ep.method}:${ep.endpoint}',
            new MockResponse(${ep.statusCode}, '${this.escapeJson(ep.responseBody)}'));`;
        }).join('\n');

        return `/**
 * Multi-endpoint HTTP Callout Mock for testing multiple API endpoints
 * Generated by Salesforce Autonomous Dev System
 */
@isTest
public class ${mockClassName} implements HttpCalloutMock {

    private Map<String, MockResponse> endpointResponses;

    /**
     * Inner class to hold response configuration
     */
    private class MockResponse {
        Integer statusCode;
        String body;
        Map<String, String> headers;

        MockResponse(Integer statusCode, String body) {
            this.statusCode = statusCode;
            this.body = body;
            this.headers = new Map<String, String>{'Content-Type' => 'application/json'};
        }
    }

    /**
     * Constructor initializes endpoint-specific responses
     */
    public ${mockClassName}() {
        this.endpointResponses = new Map<String, MockResponse>();
        this.setupDefaultResponses();
    }

    /**
     * Sets up default responses for configured endpoints
     */
    private void setupDefaultResponses() {
${responseMap}
    }

    /**
     * Implements HttpCalloutMock interface with endpoint routing
     * @param request The HTTP request to mock
     * @return Mocked HTTP response matching the endpoint
     */
    public HTTPResponse respond(HTTPRequest request) {
        HTTPResponse response = new HTTPResponse();

        // Build endpoint key from method and URL
        String endpointKey = request.getMethod() + ':';
        String endpoint = request.getEndpoint();

        // Find matching endpoint configuration
        MockResponse mockResponse = null;
        for (String key : endpointResponses.keySet()) {
            if (key.startsWith(request.getMethod()) && endpoint.contains(key.substringAfter(':'))) {
                mockResponse = endpointResponses.get(key);
                break;
            }
        }

        // Use matched response or default
        if (mockResponse != null) {
            response.setStatusCode(mockResponse.statusCode);
            response.setBody(mockResponse.body);
            for (String header : mockResponse.headers.keySet()) {
                response.setHeader(header, mockResponse.headers.get(header));
            }
        } else {
            // Default fallback response
            response.setStatusCode(404);
            response.setBody('{"error": "Endpoint not configured in mock"}');
            response.setHeader('Content-Type', 'application/json');
        }

        return response;
    }

    /**
     * Adds or updates a response for a specific endpoint
     * @param method HTTP method (GET, POST, etc.)
     * @param endpoint Endpoint URL or path fragment
     * @param statusCode HTTP status code
     * @param responseBody Response body string
     */
    public void setResponse(String method, String endpoint, Integer statusCode, String responseBody) {
        String key = method + ':' + endpoint;
        endpointResponses.put(key, new MockResponse(statusCode, responseBody));
    }
}`;
    }

    /**
     * Generates a StubProvider implementation for interface mocking
     * @param {string} interfaceName - Name of the interface to mock
     * @param {Array} methods - Array of method signatures
     * @returns {string} Complete Apex stub provider class
     */
    generateStubProvider(interfaceName, methods) {
        const methodStubs = methods.map(method => {
            return `    /**
     * Stub implementation for ${method.name}
     * Override this method in tests to provide custom behavior
     */
    public ${method.returnType} ${method.name}(${method.parameters.join(', ')}) {
        // Track method invocation
        incrementCallCount('${method.name}');

        // Return configured stub response or default
        if (stubbedResponses.containsKey('${method.name}')) {
            return (${method.returnType}) stubbedResponses.get('${method.name}');
        }

        ${this.generateDefaultReturn(method.returnType)}
    }`;
        }).join('\n\n');

        return `/**
 * Stub Provider for ${interfaceName} interface
 * Generated by Salesforce Autonomous Dev System
 */
@isTest
public class ${interfaceName}Stub implements ${interfaceName} {

    private Map<String, Integer> methodCallCounts;
    private Map<String, Object> stubbedResponses;

    /**
     * Constructor initializes tracking maps
     */
    public ${interfaceName}Stub() {
        this.methodCallCounts = new Map<String, Integer>();
        this.stubbedResponses = new Map<String, Object>();
    }

    /**
     * Sets a stubbed response for a method
     * @param methodName Name of method to stub
     * @param response Response value to return
     */
    public void setResponse(String methodName, Object response) {
        this.stubbedResponses.put(methodName, response);
    }

    /**
     * Gets the number of times a method was called
     * @param methodName Name of method
     * @return Number of invocations
     */
    public Integer getCallCount(String methodName) {
        return this.methodCallCounts.containsKey(methodName)
            ? this.methodCallCounts.get(methodName)
            : 0;
    }

    /**
     * Verifies a method was called at least once
     * @param methodName Name of method to verify
     */
    public void verifyCalled(String methodName) {
        System.assert(getCallCount(methodName) > 0,
            methodName + ' was not called');
    }

    /**
     * Verifies a method was called exactly N times
     * @param methodName Name of method to verify
     * @param expectedCount Expected number of calls
     */
    public void verifyCalledTimes(String methodName, Integer expectedCount) {
        Integer actualCount = getCallCount(methodName);
        System.assertEquals(expectedCount, actualCount,
            methodName + ' was called ' + actualCount + ' times, expected ' + expectedCount);
    }

    /**
     * Increments call count for a method
     */
    private void incrementCallCount(String methodName) {
        Integer currentCount = getCallCount(methodName);
        this.methodCallCounts.put(methodName, currentCount + 1);
    }

${methodStubs}
}`;
    }

    /**
     * Generates a Test Data Builder pattern class for an SObject
     * @param {string} sobjectType - Name of the SObject
     * @param {Array} fields - Array of field definitions
     * @returns {string} Complete Apex test data builder class
     */
    generateTestDataBuilder(sobjectType, fields) {
        const fieldSetters = fields.map(field => {
            return `    /**
     * Sets ${field.name} field
     * @param value Value to set
     * @return This builder for method chaining
     */
    public ${sobjectType}Builder with${this.capitalize(field.name)}(${field.type} value) {
        this.record.put('${field.name}', value);
        return this;
    }`;
        }).join('\n\n');

        const defaultFields = fields
            .filter(f => f.required)
            .map(f => {
                return `        this.record.put('${f.name}', ${this.generateDefaultValue(f.type, f.name)});`;
            })
            .join('\n');

        return `/**
 * Test Data Builder for ${sobjectType}
 * Generated by Salesforce Autonomous Dev System
 *
 * Usage:
 *   ${sobjectType} testRecord = new ${sobjectType}Builder()
 *       .withName('Test Record')
 *       .withStatus('Active')
 *       .build();
 */
@isTest
public class ${sobjectType}Builder {

    private ${sobjectType} record;

    /**
     * Constructor creates new ${sobjectType} with required fields populated
     */
    public ${sobjectType}Builder() {
        this.record = new ${sobjectType}();
        this.setRequiredFields();
    }

    /**
     * Sets required fields to default values
     */
    private void setRequiredFields() {
${defaultFields}
    }

${fieldSetters}

    /**
     * Builds and returns the ${sobjectType} record
     * @return Configured ${sobjectType} record
     */
    public ${sobjectType} build() {
        return this.record;
    }

    /**
     * Builds and inserts the ${sobjectType} record
     * @return Inserted ${sobjectType} record with Id
     */
    public ${sobjectType} create() {
        insert this.record;
        return this.record;
    }

    /**
     * Builds a list of ${sobjectType} records with the same configuration
     * @param count Number of records to create
     * @return List of configured ${sobjectType} records
     */
    public List<${sobjectType}> buildList(Integer count) {
        List<${sobjectType}> records = new List<${sobjectType}>();
        for (Integer i = 0; i < count; i++) {
            ${sobjectType} clonedRecord = this.record.clone(false, true, false, false);
            // Make each record unique by appending index to name field if present
            if (clonedRecord.get('Name') != null) {
                clonedRecord.put('Name', clonedRecord.get('Name') + ' ' + i);
            }
            records.add(clonedRecord);
        }
        return records;
    }

    /**
     * Builds and inserts a list of ${sobjectType} records
     * @param count Number of records to create
     * @return List of inserted ${sobjectType} records with Ids
     */
    public List<${sobjectType}> createList(Integer count) {
        List<${sobjectType}> records = buildList(count);
        insert records;
        return records;
    }
}`;
    }

    /**
     * Generates a database mock pattern for testing without DML
     * @param {string} className - Name for the database mock class
     * @returns {string} Complete Apex database mock utility
     */
    generateDatabaseMock(className) {
        return `/**
 * Database Mock Utility for testing without actual DML operations
 * Generated by Salesforce Autonomous Dev System
 */
@isTest
public class ${className} {

    private static Integer mockIdCounter = 1;
    private static Map<String, List<SObject>> mockDatabase = new Map<String, List<SObject>>();

    /**
     * Mocks insert operation by assigning fake IDs
     * @param records Records to mock insert
     */
    public static void mockInsert(List<SObject> records) {
        String sobjectType = String.valueOf(records[0].getSObjectType());

        for (SObject record : records) {
            // Assign mock ID
            record.Id = generateMockId(sobjectType);
        }

        // Store in mock database
        if (!mockDatabase.containsKey(sobjectType)) {
            mockDatabase.put(sobjectType, new List<SObject>());
        }
        mockDatabase.get(sobjectType).addAll(records);
    }

    /**
     * Mocks insert for single record
     * @param record Record to mock insert
     */
    public static void mockInsert(SObject record) {
        mockInsert(new List<SObject>{ record });
    }

    /**
     * Retrieves mock records by type
     * @param sobjectType SObject type name
     * @return List of mock records
     */
    public static List<SObject> getMockRecords(String sobjectType) {
        return mockDatabase.containsKey(sobjectType)
            ? mockDatabase.get(sobjectType)
            : new List<SObject>();
    }

    /**
     * Clears all mock data
     */
    public static void clearMockDatabase() {
        mockDatabase.clear();
        mockIdCounter = 1;
    }

    /**
     * Generates a fake Salesforce ID
     * @param sobjectType SObject type for ID prefix
     * @return Fake 18-character ID
     */
    private static Id generateMockId(String sobjectType) {
        // Get key prefix for the SObject type
        String prefix = Schema.getGlobalDescribe()
            .get(sobjectType)
            .getDescribe()
            .getKeyPrefix();

        // Generate remaining 12 characters (use counter padded to 12 digits)
        String counter = String.valueOf(mockIdCounter++).leftPad(12, '0');

        // Combine prefix and counter (15 characters)
        String id15 = prefix + counter;

        // Salesforce IDs are 18 characters, we'll just append 'AAA' for mock purposes
        return Id.valueOf(id15 + 'AAA');
    }
}`;
    }

    /**
     * Escapes JSON string for embedding in Apex string literals
     */
    escapeJson(json) {
        if (typeof json === 'object') {
            json = JSON.stringify(json);
        }
        return json
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r');
    }

    /**
     * Generates default return value based on type
     */
    generateDefaultReturn(returnType) {
        if (returnType === 'void') {
            return 'return;';
        }

        const typeMap = {
            'String': "return '';",
            'Integer': 'return 0;',
            'Long': 'return 0;',
            'Decimal': 'return 0.0;',
            'Double': 'return 0.0;',
            'Boolean': 'return false;',
            'Date': 'return Date.today();',
            'DateTime': 'return DateTime.now();',
            'Id': "return null;",
            'Object': 'return null;'
        };

        if (typeMap[returnType]) {
            return typeMap[returnType];
        }

        // Handle List types
        if (returnType.startsWith('List<')) {
            return `return new ${returnType}();`;
        }

        // Handle Map types
        if (returnType.startsWith('Map<')) {
            return `return new ${returnType}();`;
        }

        // Handle Set types
        if (returnType.startsWith('Set<')) {
            return `return new ${returnType}();`;
        }

        // Default to null for custom objects
        return 'return null;';
    }

    /**
     * Generates a default value for a field based on its type
     */
    generateDefaultValue(fieldType, fieldName) {
        const typeMap = {
            'String': `'Test ${fieldName}'`,
            'Integer': '100',
            'Decimal': '100.0',
            'Double': '100.0',
            'Boolean': 'true',
            'Date': 'Date.today()',
            'DateTime': 'DateTime.now()',
            'Email': `'test@example.com'`,
            'Phone': `'555-0100'`,
            'Url': `'https://example.com'`
        };

        return typeMap[fieldType] || 'null';
    }

    /**
     * Capitalizes first letter of a string
     */
    capitalize(str) {
        if (!str) return '';
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
}
